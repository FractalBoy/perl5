#!/usr/bin/perl
use strict;
use warnings;
use Carp;
use File::Spec;
use Getopt::Long;
require "./Porting/manifest_lib.pl";

=head1 NAME

add-pod-file - Utility to add new F<pod/*.pod> file to core distribution

=head1 USAGE

After C<make test_prep> has been run, call from top level of Perl 5 core distribution:

   Porting/add-pod-file --stub=<XXX> --abstract=<YYY> --section=<Z>

=cut

=pod

Overview
Tutorials
Reference Manual
Internals and C Language Interface
Miscellaneous
Language-Specific
Platform-Specific

=cut

my @man_sections = (
    O   => 'Overview',
    T   => 'Tutorials',
    R   => 'Reference Manual',
    I   => 'Internals and C Language Interface',
    M   => 'Miscellaneous',
    L   => 'Language-Specific',
    P   => 'Platform-Specific',
);

my @man_section_abbrevs = ();
my $man_sections_str = '';
for (my $i=0; $i<= $#man_sections; $i+=2) {
    my $j = $i+1;
    push @man_section_abbrevs, $man_sections[$i];
    $man_sections_str .= "\t$man_sections[$i] => $man_sections[$j]\n";
}
my %man_sections_seen = map { $_ => 1 } @man_section_abbrevs;

my ($stub, $abstract, $section, $verbose) = ('') x 4;
GetOptions(
    "stub=s"        => \$stub,
    "abstract=s"    => \$abstract,
    "section=s"     => \$section,
    "verbose"       => \$verbose,
) or croak("Error in command line arguments to add-pod-file.pl\n");
croak "$0: Must provide value for command-line switch 'stub'"
    unless length($stub);
croak "$0: Must provide value for command-line switch 'abstract'"
    unless length($abstract);
croak "$0: Must provide value for command-line switch 'section'"
    unless length($section);
my $section_croak = "$0: Value for command-line switch must be one of @man_section_abbrevs\n";
$section_croak .= "    Select one initial from:\n$man_sections_str";
croak $section_croak unless $man_sections_seen{$section};

my $newpodfile = "$stub.pod";
my $newpodpath = File::Spec->catfile('pod', $newpodfile);
croak "Unable to locate new file '$newpodpath'" unless -f $newpodpath;

# Step 1:  Do a basic test of the validity of the POD in $newpodpath
my $rv;
system(qq|$^X cpan/Pod-Checker/podchecker $newpodpath|)
    and croak "$newpodpath has POD errors";

# Step 2:  Insert entry for $newepodpath into MANIFEST
# Follows style of Porting/manisort (somewhat)

my $manifest = 'MANIFEST';
open(my $IN, '<', $manifest)
    or croak "Can't open $manifest for reading";
my @manifest_orig = <$IN>;
close($IN) or croak "Can't close $manifest after reading";
chomp(@manifest_orig);

#my %seen= ( '' => 1 ); # filter out blank lines
#my @sorted = grep { !$seen{$_}++ } sort_manifest(@manifest_orig);
##if ($verbose) { print "XXX: $_\n" for @sorted; }

my (@before_pod, @pod, @after_pod, @new_manifest);
my $seen_pod = 0;
while (my $l = shift(@manifest_orig)) {
    if (! $seen_pod and $l !~ m{^pod\/}) {
        push @before_pod, $l;
    }
    elsif ($l =~ m{^pod\/}) {
        push @pod, $l;
        $seen_pod++;
    }
    else {
        push @after_pod, $l;
    }
}

=pod

PROBLEM: MANIFEST is not (at least currently) sorted in the way returned by 'sort'.
Hence, using @sorted as the basis for inserting a new entry into MANIFEST leads to 
an enormous 'git diff -- MANIFEST'.

The most we want to do is to get the new entry into that section of MANIFEST whose
lines match '^pod\/'.

=cut

print "Inserting entry for '$newpodpath' into MANIFEST; text will be '$abstract'\n" if $verbose;
my $new_entry = "$newpodpath\t\t$abstract";
my @new_pod = sort (@pod, $new_entry);

open(my $OUT, '>', $manifest)
    or croak "Can't open $manifest for writing";
binmode($OUT);
print($OUT join("\n", @before_pod, @new_pod, @after_pod), "\n");
close($OUT) or croak "Can't close $manifest after writing";

# Step 3: Add entry into pod/perl.pod



# Step 4: run './perl -Ilib Porting/pod_rules.pl --build-podmak' to update win32/pod.mak.

print "Finished!\n" if $verbose;

