#!/usr/bin/perl
use strict;
use warnings;
use Carp;
use File::Spec;
use Getopt::Long;
require "./Porting/manifest_lib.pl";
use Data::Dumper;

=head1 NAME

add-pod-file - Utility to add new F<pod/*.pod> file to core distribution

=head1 USAGE

After C<make test_prep> has been run, call from top level of Perl 5 core distribution:

   Porting/add-pod-file --stub=<XXX> --abstract=<YYY> --section=<Z>

=cut

=pod

Overview
Tutorials
Reference Manual
Internals and C Language Interface
Miscellaneous
Language-Specific
Platform-Specific

=cut

my @man_sections = (
    O   => 'Overview',
    T   => 'Tutorials',
    R   => 'Reference Manual',
    I   => 'Internals and C Language Interface',
    M   => 'Miscellaneous',
    L   => 'Language-Specific',
    P   => 'Platform-Specific',
);

my @man_section_abbrevs = ();
my $man_sections_str = '';
for (my $i=0; $i<= $#man_sections; $i+=2) {
    my $j = $i+1;
    push @man_section_abbrevs, $man_sections[$i];
    $man_sections_str .= "\t$man_sections[$i] => $man_sections[$j]\n";
}
my %man_sections_seen = map { $_ => 1 } @man_section_abbrevs;
my $man_sections = { @man_sections };

my ($stub, $abstract, $section, $verbose) = ('') x 4;
GetOptions(
    "stub=s"        => \$stub,
    "abstract=s"    => \$abstract,
    "section=s"     => \$section,
    "verbose"       => \$verbose,
) or croak("Error in command line arguments to add-pod-file.pl\n");
croak "$0: Must provide value for command-line switch 'stub'"
    unless length($stub);
croak "$0: Must provide value for command-line switch 'abstract'"
    unless length($abstract);
croak "$0: Must provide value for command-line switch 'section'"
    unless length($section);
my $section_croak = "$0: Value for command-line switch must be one of @man_section_abbrevs\n";
$section_croak .= "    Select one initial from:\n$man_sections_str";
croak $section_croak unless $man_sections_seen{$section};

my $newpodfile = "$stub.pod";
my $newpodpath = File::Spec->catfile('pod', $newpodfile);
croak "Unable to locate new file '$newpodpath'" unless -f $newpodpath;

# Step 1:  Do a basic test of the validity of the POD in $newpodpath
my $rv;
system(qq|$^X cpan/Pod-Checker/podchecker $newpodpath|)
    and croak "$newpodpath has POD errors";

# Step 2:  Insert entry for $newepodpath into MANIFEST
# Follows style of Porting/manisort (somewhat)

my $manifest = 'MANIFEST';
open(my $IN, '<', $manifest)
    or croak "Can't open $manifest for reading";
my @manifest_orig = <$IN>;
close($IN) or croak "Can't close $manifest after reading";
chomp(@manifest_orig);

my (@before_pod, @pod, @after_pod);
my $seen_pod = 0;
while (my $l = shift(@manifest_orig)) {
    if (! $seen_pod and $l !~ m{^pod\/}) {
        push @before_pod, $l;
    }
    elsif ($l =~ m{^pod\/}) {
        push @pod, $l;
        $seen_pod++;
    }
    else {
        push @after_pod, $l;
    }
}

print "Inserting entry for '$newpodpath' into MANIFEST; text will be '$abstract'\n" if $verbose;
my $new_entry = "$newpodpath\t\t$abstract";
my @new_pod = sort_manifest(@pod, $new_entry);

open(my $OUT, '>', $manifest)
    or croak "Can't open $manifest for writing";
binmode($OUT);
print($OUT join("\n", @before_pod, @new_pod, @after_pod), "\n");
close($OUT) or croak "Can't close $manifest after writing";

# Step 3: Add entry into pod/perl.pod

=pod

The committer will have to make a reasonable choice as to which section of
F<pod/perl.pod> the new .pod file should be listed under.  For a first pass,
let's put the new entry at the end of the C<^=head2> section specified by the
committer with the single-initial provided for command-line switch C<section>.

We'll have to read the existing F<pod/perl.pod> into memory, chunk it into before/during/after sections as we did with F<MANIFEST> above, then add the new entry at the end of the 'during' chunk.

=cut

my $perlpod = "./pod/perl.pod";

open(my $IN1, '<', $perlpod)
    or croak "Can't open $perlpod for reading";
my $perlpod_str;
{
    local $/;
    $perlpod_str = <$IN1>;
}
close($IN1) or croak "Can't close $perlpod after reading";

my $section_head = "=head2 $man_sections->{$section}\n";
my @chunks = split $section_head, $perlpod_str;

my @subchunks = ();
my @balance = split /\n/, $chunks[1];
my (@target_section, @after_section);

my $this = 0;
for my $l (@balance) {
    if ($l =~ m/^=(head2|for)/) {
        push @after_section, $l;
        $this++;
    }
    elsif (! $this) {
        push @target_section, $l;
    }
    else {
        push @after_section, $l;
    }
}

open(my $OUT1, '>', $perlpod)
    or croak "Can't open $perlpod for writing";
print $OUT1 "$chunks[0]";
print $OUT1 $section_head;
print $OUT1 join("\n" => @target_section, "    $new_entry"), "\n\n";
print $OUT1 join("\n" => @after_section), "\n";
close $OUT1 or croak "Can't close $perlpod after writing";

# Step 4: run './perl -Ilib Porting/pod_rules.pl --build-podmak' to update win32/pod.mak.

print "Finished!\n" if $verbose;

